#!/usr/bin/env node

"use strict";

process.title = 'test-require';

const argv = require('minimist')(process.argv);

const logFactory = require('../lib/log-factory');

if (argv.log) {
  if (logFactory.isLogLevel(argv.log)) {
    logFactory.setDefaultLevel(argv.log);
  } else {
    logFactory.setConfigFromFile(argv.log);
  }
}

let path = require('path');
let root = argv.root || process.cwd();
let relativePath = argv.path;

let useFullPath = argv.useFull;
let requirePath = useFullPath ? path.join(root, relativePath) : relativePath;

const vm = require('vm');
const fs = require('fs-extra');

let src = fs.readFileSync(relativePath);

console.log(src);

let validLibs = {
  lodash: require('lodash')
};

let mockRequire = (name) => {
  if(validLibs.hasOwnProperty(name)){
    return validLibs[name];
  } else {
    throw new Error(`Can't find module ${name}`);
  }
};

let localModule = {
  exports: {} 
};

const script = new vm.Script(src); 
const sandbox = {require: mockRequire, module: localModule, exports: localModule.exports};
script.runInNewContext(sandbox);

// console.log('obj: ', obj);
console.log('obj: ', localModule);

let out = localModule.exports.createOutcome({correctResponse: {}}, {}, {});
console.log(out);

// let loaded;

// const SandboxedModule = require('sandboxed-module');

// if(argv.useSandbox){
//   loaded = SandboxedModule.require(requirePath, { requires: {lodash: require('lodash')}});
// } else {
//  loaded = require(requirePath);
// }

// console.log(loaded);